<?php

declare(strict_types=1);

namespace Aristek\Bundle\DynamodbBundle\ODM;

use Aristek\Bundle\DynamodbBundle\ODM\Id\UuidGenerator;
use Aristek\Bundle\DynamodbBundle\ODM\Mapping\ClassMetadataFactory;
use Aristek\Bundle\DynamodbBundle\ODM\Mapping\Driver\AnnotationDriver;
use Aristek\Bundle\DynamodbBundle\ODM\PersistentCollection\DefaultPersistentCollectionFactory;
use Aristek\Bundle\DynamodbBundle\ODM\PersistentCollection\DefaultPersistentCollectionGenerator;
use Aristek\Bundle\DynamodbBundle\ODM\PersistentCollection\PersistentCollectionFactory;
use Aristek\Bundle\DynamodbBundle\ODM\PersistentCollection\PersistentCollectionGenerator;
use Aristek\Bundle\DynamodbBundle\ODM\Proxy\FileLocator;
use Aristek\Bundle\DynamodbBundle\ODM\Repository\DefaultRepositoryFactory;
use Aristek\Bundle\DynamodbBundle\ODM\Repository\DocumentRepository;
use Aristek\Bundle\DynamodbBundle\ODM\Repository\ObjectRepositoryInterface;
use Aristek\Bundle\DynamodbBundle\ODM\Repository\RepositoryFactory;
use Aws\DynamoDb\DynamoDbClient;
use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Cache\Psr6\DoctrineProvider;
use Doctrine\Persistence\Mapping\Driver\MappingDriver;
use InvalidArgumentException;
use ProxyManager\Configuration as ProxyManagerConfiguration;
use ProxyManager\Factory\LazyLoadingGhostFactory;
use ProxyManager\GeneratorStrategy\EvaluatingGeneratorStrategy;
use ProxyManager\GeneratorStrategy\FileWriterGeneratorStrategy;
use Psr\Cache\CacheItemPoolInterface;
use ReflectionClass;
use ReflectionException;
use function interface_exists;
use function sprintf;

/**
 * Configuration class for the DocumentManager. When setting up your DocumentManager
 * you can optionally specify an instance of this class as the second argument.
 * If you do not pass a configuration object, a blank one will be created for you.
 *
 *     <?php
 *
 *     $config = new Configuration();
 *     $dm = DocumentManager::create(new Connection(), $config);
 */
class Configuration
{
    /**
     * Always generates a new proxy/hydrator/persistent collection in every request.
     *
     * This is only sane during development.
     * Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_ALWAYS = 1;
    /**
     * Generate the proxy/hydrator/persistent collection classes using eval().
     *
     * This strategy is only sane for development.
     * Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_EVAL = 3;
    /**
     * Autogenerate the proxy/hydrator/persistent collection class when the file does not exist.
     *
     * This strategy causes a file exists call whenever any proxy/hydrator is used the
     * first time in a request. Copied from \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_FILE_NOT_EXISTS = 2;
    /**
     * Never autogenerate a proxy/hydrator/persistent collection and rely that
     * it was generated by some process before deployment. Copied from
     * \Doctrine\Common\Proxy\AbstractProxyFactory.
     */
    public const AUTOGENERATE_NEVER = 0;

    /**
     * Array of attributes for this configuration instance.
     */
    private array $attributes = [];

    private int $autoGenerateProxyClasses = self::AUTOGENERATE_EVAL;

    private ?string $db = null;

    private ?array $dynamodbConfig = null;

    private ?CacheItemPoolInterface $metadataCache = null;

    private ProxyManagerConfiguration $proxyManagerConfiguration;

    private ?int $uuidVersion = null;

    public function __construct()
    {
        $this->proxyManagerConfiguration = new ProxyManagerConfiguration();
        $this->setAutoGenerateProxyClasses(self::AUTOGENERATE_FILE_NOT_EXISTS);
    }

    /**
     * Adds a namespace under a certain alias.
     */
    public function addDocumentNamespace(string $alias, string $namespace): void
    {
        $this->attributes['documentNamespaces'][$alias] = $namespace;
    }

    /**
     * Add a filter to the list of possible filters.
     *
     * @param array<string, mixed> $parameters
     */
    public function addFilter(string $name, string $className, array $parameters = []): void
    {
        $this->attributes['filters'][$name] = [
            'class'      => $className,
            'parameters' => $parameters,
        ];
    }

    public function buildGhostObjectFactory(): LazyLoadingGhostFactory
    {
        return new LazyLoadingGhostFactory(clone $this->getProxyManagerConfiguration());
    }

    /**
     * Gets an int flag that indicates whether hydrator classes should always be regenerated
     * during each script execution.
     */
    public function getAutoGenerateHydratorClasses(): int
    {
        return $this->attributes['autoGenerateHydratorClasses'] ?? self::AUTOGENERATE_ALWAYS;
    }

    /**
     * Gets integer flag that indicates how and when persistent collection classes should be generated.
     */
    public function getAutoGeneratePersistentCollectionClasses(): int
    {
        return $this->attributes['autoGeneratePersistentCollectionClasses'] ?? self::AUTOGENERATE_ALWAYS;
    }

    /**
     * Gets an int flag that indicates whether proxy classes should always be regenerated
     * during each script execution.
     */
    public function getAutoGenerateProxyClasses(): int
    {
        return $this->autoGenerateProxyClasses;
    }

    /**
     * Sets an int flag that indicates whether proxy classes should always be regenerated
     * during each script execution.
     *
     * @throws InvalidArgumentException If an invalid mode was given.
     */
    public function setAutoGenerateProxyClasses(int $mode): void
    {
        $this->autoGenerateProxyClasses = $mode;
        $proxyManagerConfig = $this->getProxyManagerConfiguration();

        switch ($mode) {
            case self::AUTOGENERATE_FILE_NOT_EXISTS:
                $proxyManagerConfig->setGeneratorStrategy(
                    new FileWriterGeneratorStrategy(
                        new FileLocator($proxyManagerConfig->getProxiesTargetDir()),
                    )
                );

                break;
            case self::AUTOGENERATE_EVAL:
                $proxyManagerConfig->setGeneratorStrategy(new EvaluatingGeneratorStrategy());

                break;
            default:
                throw new InvalidArgumentException(
                    'Invalid proxy generation strategy given - only AUTOGENERATE_FILE_NOT_EXISTS and AUTOGENERATE_EVAL are supported.'
                );
        }
    }

    public function getClassMetadataFactoryName(): string
    {
        if (!isset($this->attributes['classMetadataFactoryName'])) {
            $this->attributes['classMetadataFactoryName'] = ClassMetadataFactory::class;
        }

        return $this->attributes['classMetadataFactoryName'];
    }

    public function getDatabase(): string
    {
        if ($this->db === null) {
            throw new InvalidArgumentException(
                sprintf('Database not provided. Call %s::setDatabase', self::class)
            );
        }

        return $this->db;
    }

    public function getDefaultCommitOptions(): array
    {
        return $this->attributes['defaultCommitOptions'] ?? [];
    }

    /**
     * Gets the default DB to use for all Documents that do not specify a database.
     */
    public function getDefaultDB(): ?string
    {
        return $this->attributes['defaultDB'] ?? null;
    }

    public function getDefaultDocumentRepositoryClassName(): string
    {
        return $this->attributes['defaultDocumentRepositoryClassName'] ?? DocumentRepository::class;
    }

    /**
     * Retrieves the list of registered document namespace aliases.
     *
     * @return array<string, string>
     */
    public function getDocumentNamespaces(): array
    {
        return $this->attributes['documentNamespaces'];
    }

    public function getDynamoDbClient(): DynamoDbClient
    {
        return new DynamoDbClient(args: $this->getDynamodbConfig());
    }

    public function getDynamodbConfig(): array
    {
        if ($this->dynamodbConfig === null) {
            throw new InvalidArgumentException(
                sprintf('DynamodbConfig not provided. Call %s::setDynamodbConfig', self::class)
            );
        }

        return $this->dynamodbConfig;
    }

    public function setDynamodbConfig(array $dynamodbConfig): void
    {
        $this->dynamodbConfig = $dynamodbConfig;
    }

    public function getFilterClassName(string $name): ?string
    {
        return isset($this->attributes['filters'][$name]) ? $this->attributes['filters'][$name]['class'] : null;
    }

    public function getFilterParameters(string $name): array
    {
        return isset($this->attributes['filters'][$name]) ? $this->attributes['filters'][$name]['parameters'] : [];
    }

    public function getHydratorDir(): ?string
    {
        return $this->attributes['hydratorDir'] ?? null;
    }

    public function getHydratorNamespace(): ?string
    {
        return $this->attributes['hydratorNamespace'] ?? null;
    }

    public function getMetadataCache(): ?CacheItemPoolInterface
    {
        return $this->metadataCache;
    }

    public function setMetadataCache(CacheItemPoolInterface $cache): void
    {
        $this->metadataCache = $cache;
        $this->attributes['metadataCacheImpl'] = DoctrineProvider::wrap($cache);
    }

    /**
     * Gets the cache driver implementation that is used for the mapping metadata.
     */
    public function getMetadataDriverImpl(): ?MappingDriver
    {
        return $this->attributes['metadataDriverImpl'] ?? null;
    }

    public function getPersistentCollectionDir(): ?string
    {
        return $this->attributes['persistentCollectionDir'] ?? null;
    }

    public function getPersistentCollectionFactory(): PersistentCollectionFactory
    {
        if (!isset($this->attributes['persistentCollectionFactory'])) {
            $this->attributes['persistentCollectionFactory'] = new DefaultPersistentCollectionFactory();
        }

        return $this->attributes['persistentCollectionFactory'];
    }

    /**
     * @throws ConfigurationException
     */
    public function getPersistentCollectionGenerator(): PersistentCollectionGenerator
    {
        if (!isset($this->attributes['persistentCollectionGenerator'])) {
            if ($this->getPersistentCollectionDir() === null) {
                throw ConfigurationException::persistentCollectionDirMissing();
            }

            if ($this->getPersistentCollectionNamespace() === null) {
                throw ConfigurationException::persistentCollectionNamespaceMissing();
            }

            $this->attributes['persistentCollectionGenerator'] = new DefaultPersistentCollectionGenerator(
                $this->getPersistentCollectionDir(),
                $this->getPersistentCollectionNamespace(),
            );
        }

        return $this->attributes['persistentCollectionGenerator'];
    }

    public function getPersistentCollectionNamespace(): ?string
    {
        return $this->attributes['persistentCollectionNamespace'] ?? null;
    }

    /**
     * Gets the directory where Doctrine generates any necessary proxy class files.
     */
    public function getProxyDir(): ?string
    {
        return $this->getProxyManagerConfiguration()->getProxiesTargetDir();
    }

    public function getProxyManagerConfiguration(): ProxyManagerConfiguration
    {
        return $this->proxyManagerConfiguration;
    }

    public function getProxyNamespace(): ?string
    {
        return $this->getProxyManagerConfiguration()->getProxiesNamespace();
    }

    public function getRepositoryFactory(): RepositoryFactory
    {
        return $this->attributes['repositoryFactory'] ?? new DefaultRepositoryFactory();
    }

    public function getUuidVersion(): ?int
    {
        return $this->uuidVersion;
    }

    public function setUuidVersion(?int $uuidVersion): self
    {
        UuidGenerator::validateVersion($uuidVersion);

        $this->uuidVersion = $uuidVersion;

        return $this;
    }

    /**
     * Add a new default annotation driver with a correctly configured annotation reader.
     *
     * @param string[] $paths
     */
    public function newDefaultAnnotationDriver(array $paths = []): AnnotationDriver
    {
        $reader = new AnnotationReader();

        return new AnnotationDriver($reader, $paths);
    }

    /**
     * Sets an int flag that indicates whether hydrator classes should always be regenerated
     * during each script execution.
     */
    public function setAutoGenerateHydratorClasses(int $mode): void
    {
        $this->attributes['autoGenerateHydratorClasses'] = $mode;
    }

    /**
     * Sets integer flag that indicates how and when persistent collection classes should be generated.
     */
    public function setAutoGeneratePersistentCollectionClasses(int $mode): void
    {
        $this->attributes['autoGeneratePersistentCollectionClasses'] = $mode;
    }

    public function setClassMetadataFactoryName(string $cmfName): void
    {
        $this->attributes['classMetadataFactoryName'] = $cmfName;
    }

    public function setDatabase(?string $db): void
    {
        $this->db = $db;
    }

    public function setDefaultCommitOptions(array $defaultCommitOptions): void
    {
        $this->attributes['defaultCommitOptions'] = $defaultCommitOptions;
    }

    /**
     * Sets the default DB to use for all Documents that do not specify a database.
     */
    public function setDefaultDB(string $defaultDB): void
    {
        $this->attributes['defaultDB'] = $defaultDB;
    }

    /**
     * @throws DynamoDBException|ReflectionException If not is a ObjectRepository.
     */
    public function setDefaultDocumentRepositoryClassName(string $className): void
    {
        $reflectionClass = new ReflectionClass($className);

        if (!$reflectionClass->implementsInterface(ObjectRepositoryInterface::class)) {
            throw DynamoDBException::invalidDocumentRepository($className);
        }

        $this->attributes['defaultDocumentRepositoryClassName'] = $className;
    }

    /**
     * Set the document alias map
     *
     * @param array<string, string> $documentNamespaces
     */
    public function setDocumentNamespaces(array $documentNamespaces): void
    {
        $this->attributes['documentNamespaces'] = $documentNamespaces;
    }

    public function setHydratorDir(string $dir): void
    {
        $this->attributes['hydratorDir'] = $dir;
    }

    public function setHydratorNamespace(string $ns): void
    {
        $this->attributes['hydratorNamespace'] = $ns;
    }

    /**
     * Sets the cache driver implementation that is used for metadata caching.
     *
     * @todo Force parameter to be a Closure to ensure lazy evaluation
     *       (as soon as a metadata cache is in effect, the driver never needs to initialize).
     */
    public function setMetadataDriverImpl(MappingDriver $driverImpl): void
    {
        $this->attributes['metadataDriverImpl'] = $driverImpl;
    }

    public function setPersistentCollectionDir(string $dir): void
    {
        $this->attributes['persistentCollectionDir'] = $dir;
    }

    public function setPersistentCollectionFactory(PersistentCollectionFactory $persistentCollectionFactory): void
    {
        $this->attributes['persistentCollectionFactory'] = $persistentCollectionFactory;
    }

    public function setPersistentCollectionGenerator(PersistentCollectionGenerator $persistentCollectionGenerator): void
    {
        $this->attributes['persistentCollectionGenerator'] = $persistentCollectionGenerator;
    }

    public function setPersistentCollectionNamespace(string $ns): void
    {
        $this->attributes['persistentCollectionNamespace'] = $ns;
    }

    /**
     * Sets the directory where Doctrine generates any necessary proxy class files.
     */
    public function setProxyDir(string $dir): void
    {
        $this->getProxyManagerConfiguration()->setProxiesTargetDir($dir);

        // Recreate proxy generator to ensure its path was updated
        if ($this->autoGenerateProxyClasses !== self::AUTOGENERATE_FILE_NOT_EXISTS) {
            return;
        }

        $this->setAutoGenerateProxyClasses($this->autoGenerateProxyClasses);
    }

    public function setProxyNamespace(string $ns): void
    {
        $this->getProxyManagerConfiguration()->setProxiesNamespace($ns);
    }

    public function setRepositoryFactory(RepositoryFactory $repositoryFactory): void
    {
        $this->attributes['repositoryFactory'] = $repositoryFactory;
    }
}

interface_exists(MappingDriver::class);
